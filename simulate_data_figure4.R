library(cellAlign)
require(ggplot2)
library(geiger)
library(sp)
library(rgeos)

##Figure 4A
generate_data = function(slope, sd, population_size=10000){
  "
Generates a population of data that has specified slope and deviation. The Y intercept is set to 1. 
It also generates a population of data to be used for showing no increase expression (a flat line). 
This flat linecomes from the average expression value of the original population
Parameters:
  slope: what the slope of the population should be. Mimics increaseing (or decreasing) protein expression
  sd: the standard devation of the data. Measures the biological variability in data
  population_size: how many data points to generate. Defaults to 1,000
  
Return: 
  A list, where time_traj is the pseudotime values, 
  Y is the expression values for the population with slope and sd, 
  and flat_Y is the expression values for the flat line
"
  X = runif(population_size)
  X = as.data.frame(sort(X))
  X = t(X)
  
  Ynorm <-  slope * X +1+ rnorm(population_size,sd = sd)
  
  Yflat = rep(mean(Ynorm), population_size)
  Yflat = t(Yflat)
  colnames(Ynorm) = paste0("t", 1:population_size)
  rownames(Ynorm) = "gene"
  colnames(Yflat) = paste0("t", 1:population_size)
  rownames(Yflat) = "gene"
  
  X = t(X)
  rownames(X) = paste0("t", 1:population_size)
  colnames(X) = NULL
  
  data = list("time_traj" = X, "Y" = Ynorm, "flat_Y"=Yflat)
  
  return(data)
  
}
subsample = function(population_data, number_of_cells){
  "
Subsamples from the population generated by the generate_data() function. 
It splits that data into quarters and samples rnadomly form each one, to get an even distribution across time. 
Parameters:
  population_data is a dataframe that is the result of generate_data() that we're going to subsample from.
  number_of_cells the number of cells to subsample
Returns:
  List where traj is the pseudotime trajectory for the subsample, and exp is the protein expression values for the subsample
"
  traj = population_data$time_traj
  exp = population_data$Y
  trajdf = as.data.frame(traj)
  
  #divide time into quarters
  q = split(as.vector(trajdf), factor(sort(rank(as.vector(trajdf))%%4)))
  first = q$`0`
  second = q$`1`
  third = q$`2`
  fourth = q$`3`
  
  #get an even number of sample from each
  remainder = number_of_cells %% 4
  s_size = number_of_cells %/% 4
  s_size_plus1 = s_size 
  s_size_plus2 = s_size 
  s_size_plus3 = s_size 
  
  if (remainder == 1){
    s_size_plus1 = s_size_plus1 + 1 
  }
  if (remainder == 2){
    s_size_plus1 = s_size_plus1 + 1 
    s_size_plus2 =  s_size_plus2+1 
  }
  if (remainder == 3){
    s_size_plus1 = s_size_plus1 + 1 
    s_size_plus2 =  s_size_plus2+1 
    s_size_plus3 = s_size_plus3 +1 
  }
  
  first_index = rownames(first)
  first_sample = sample(first_index, s_size_plus1)
  
  second_index = rownames(second)
  second_sample = sample(second_index, s_size_plus2)
  
  third_index = rownames(third)
  third_sample = sample(third_index, s_size_plus3)
  
  fourth_index = rownames(fourth)
  fourth_sample = sample(fourth_index, s_size)
  
  all_samples = c(first_sample, second_sample, third_sample, fourth_sample)
  
  #subset traj
  trajdf <- cbind(index = rownames(trajdf), trajdf)
  rownames(trajdf) <- 1:nrow(trajdf)
  traj_subset = trajdf[which((trajdf$index %in% all_samples)==TRUE),]
  rownames(traj_subset) <- traj_subset$index
  traj_subset$index=NULL
  traj_subset = as.matrix(traj_subset)
  colnames(traj_subset) = NULL
  
  
  #subset exp
  exp_subset = exp[ ,which((colnames(exp) %in% all_samples)==TRUE)]
  exp_subset = t(exp_subset)
  rownames(exp_subset)="gene"
  exp_subset = as.data.frame(exp_subset)
  
  subsample = list("traj"=traj_subset, "exp"=exp_subset)
  return(subsample)
}
interpolate = function(time_traj, expression, subsample=TRUE, number_of_points=200){
  "
Interpolates the data along the trajectory.
Data is interpolated by equally spaced points along the pseudotime trajectory. 

Paraeters:
  time_traj: the pseudo time trajectory
  expression: the protein expression values
  subsample: boolean that says weather we're interpolating a line for the subsample or the entire population. Defaults to TRUE
  number_of_points: the number of points to interpolate (the points will all be equally spaced). Defualts to 200
Return:
  A list where interpolated is a dataframe containg traj and exp for the interpolated line, 
  and points is a dataframe containing traj and exp data for the interplated points (default is set to interpolate 200 points) (not an interpolated line)
"
  Y = expression
  X = time_traj
  interGlobalLPS = cellAlign::interWeights(expDataBatch = Y, trajCond =X,
                                           winSz = 0.1, numPts = number_of_points)
  require(reshape2)
  whichgene = "gene"
  selectedLPS<-interGlobalLPS$interpolatedVals[whichgene,]
  
  dfLPSi = data.frame(traj = interGlobalLPS$traj, value=(selectedLPS), error=interGlobalLPS$error[whichgene,])
  
  if(subsample==TRUE){
    dfLPS = data.frame(traj = X, gene=t(Y[whichgene,]))
  }else{
    dfLPS = data.frame(traj = X, gene=Y[whichgene,])
  }
  dfLPSM = melt(dfLPS, id.vars = 'traj')
  
  result = list("interpolated" = dfLPSi, "points"=dfLPSM)
  return(result)
  
}
"Start with s/v = 1 (because anything less than that's no good.)"
#Generate a full population

approx_sv = function(slope, sd, number_of_cells){
  est_slope = c()
  est_sd = c()
  population = generate_data(slope=slope, sd=sd, population_size=10000)
  for(i in 1:1000){
    #subsample
    sample = subsample(population, number_of_cells=number_of_cells)
    
    #find exDev
    sample_exp = as.matrix(t(sample$exp))
    m1 <- lm(sample_exp~sample$traj) #lm for non interpolation
    m1_res = resid(m1) #List of residuals
    expSD = sd(m1_res)
    expSD
    expSlope = m1$coefficients[[2]]
    
    est_slope[i] = expSlope
    est_sd[i] = expSD
    
    
  }
  return(est_slope/est_sd)
}

cells100 = approx_sv(slope = 1, sd = 1, 100)
cells100_diff = c(1-cells100)

cells30 = approx_sv(slope = 1, sd = 1, 30)
cells30_diff = c(1-cells30)

cells20 = approx_sv(slope = 1, sd = 1, 20)
cells20_diff = c(1-cells20)

cells16 = approx_sv(slope = 1, sd = 1, 16)
cells16_diff = c(1-cells16)

cells7 = approx_sv(slope = 1, sd = 1, 7)
cells7_diff = c(1-cells7)


myData = data.frame(c100 = cells100_diff,
                    c30 = cells30_diff,
                    c20 = cells20_diff,
                    c16 = cells16_diff,
                    c7 = cells7_diff)



dir.create("data/Fig4")
write.csv(myData, "data/Fig4/fig4A")


####Figure 4B####
find_for_sample = function(pop, truesv){
  slope = c()
  sd = c()
  trsv = c()
  for(i in 1:1000){
    #subsample
    sample = subsample(pop, number_of_cells = 30)
    #find slope and sd
    sample_exp = as.matrix(t(sample$exp))
    m1 <- lm(sample_exp~sample$traj) #lm for non interpolation
    m1_res = resid(m1) #List of residuals
    expSD = sd(m1_res)
    expSlope = m1$coefficients[[2]]
    slope[i] = expSlope
    sd[i] = expSD
    trsv[i] = truesv
  }
  return(list("sd"=sd, 'slope'=slope, "trsv"=trsv))
}

pop0 = generate_data(slope=0, sd = 1, population_size = 10000) #sv = 0
pop.5 = generate_data(slope=.5, sd = 1, population_size = 10000) #sv = .5
pop1 = generate_data(slope=1, sd = 1, population_size = 10000) #sv = 1
pop1.5 = generate_data(slope=1.5, sd = 1, population_size = 10000) #sv = 1.5
pop2 = generate_data(slope=2, sd = 1, population_size = 10000) #sv = 2

sample0 = find_for_sample(pop0, 0)
sample.5 = find_for_sample(pop.5, .5)
sample1 = find_for_sample(pop1, 1)
sample1.5 = find_for_sample(pop1.5, 1.5)
sample2 = find_for_sample(pop2, 2)



full_population = data.frame("sd"=c(sample0$sd,sample.5$sd,sample1$sd,sample1.5$sd,sample2$sd),
                             
                             'slope'=c(sample0$slope,sample.5$slope, sample1$slope,sample1.5$slope,sample2$slope),
                             
                             'trsv'=c(sample0$trsv ,sample.5$trsv,sample1$trsv, sample1.5$trsv, sample2$trsv)
                             
)

write.csv(full_population, "data/Fig4/fig4B")

